# DDD总结(领域驱动设计)

## DDD是什么？

DDD(Domain Driven Design,领域驱动设计)是一种应对软件复杂的设计方法论，***<font color="red">其提倡聚焦业务领域而非技术，合理的规划业务合技术质检的依赖，</font>***从而达到稳定的领域模型来应对多变的业务需求。

## DDD如何节约业务的复杂性？

1. 分而治之。DDD通过规划四重边界，***把领域知识做了合理的固化和分层。业务域里拆分成多个限界上下文（BC），一个BC里又根据领域知识核心与否做分层，领域层里按照业务的强相关性划为聚合***。

   - 【第一重边界】确定项目的愿景与目标，确定问题空间，确定核心子领域、通用子领域与支撑子领域
   - 【第二重边界】解决方案空间里的限界上下文就是一道进程隔离层面的物理边界
   - 【第三重边界】每个限界上下文内，分层架构划分出来的接口层、领域层、应用层、基础设施层之间的隔离
   - 【第四重边界】领域层里为了保持领域的完整性和一致性，引入聚合的设计作为隔离领域模型的最小单元

2. 领域建模。***对领域知识抽象、建模，让拥有数据的领域对象也拥有相应的行为能力***。通过底层有序的建模可以灵活满足上层不同的业务流程和场景的编排。

3. 模型：

   ![分层架构的副本](/Users/chenyongcheng/programmingSoftware/markdown/markdown_pic/分层架构的副本.jpg)

4. 经典的两种模型：

   1. 洋葱架构(以领域服务为核心)

      ![洋葱架构图](/Users/chenyongcheng/programmingSoftware/markdown/markdown_pic/洋葱架构图.png)

      - 围绕独立的领域模型构建应用
      - ***内层定义接口，外层实现接口***
      - ***依赖的方向指向圆心（注意：洋葱架构提倡不破坏耦合方向的依赖都是合理的，外层可以依赖直接内层，也可以依赖更里面的层）***
      - 所有的应用代码可以独立于基础设施编译和运行

   2. 整洁架构()以领域服务为核心

      ![整洁架构图](/Users/chenyongcheng/programmingSoftware/markdown/markdown_pic/整洁架构图.jpg)

      整洁架构跟洋葱架构基本一样，只是层次上的叫法没有完全遵循DDD概念。Entities对应领域层，User Cases：应用层，这层需要串联上游和下游的资源完成具体场景的问题。Controllers、Gateways、Presenters：本质上是各类适配器，即用户接口层+基础设施层。

      特点：*依赖方向是从外层圆向内层圆。任何内层圆里的代码不应该应用外层圆的代码。越里层越解决领域逻辑。*

## 领域模型的职责分类

1. 表示模型的是：实体，值对象，领域服务。所以***<font color="red">所有的领域逻辑都应该在这三种对象中</font>***，后续的引入的领域事件也是一种领域逻辑.
2. 聚合这是为了让领域逻辑更内聚，起到保护边界的作用[一个聚合不能持有别的聚合对象]
3. 工厂与资源库是为了管理领域对象(实体，值对象，领域服务)的生命周期。***<font color="red">工厂方法负责对象的创建，资源库负责聚合的加载，添加，修改，删除。</font>***
4. 应用服务处于应用层，对领域逻辑编排，封装之后对上层接口暴露，<font color="red">***一次编排就是一个用户实例(一个服务方法对应对应用户需求的一个逻辑)***</font>

## 服务与模型

模型只是一个逻辑概念，模型的数据方面由实体，值对象，领域消息来承载。领鱼腥味包括实体类行为，值对象行为和领域服务的行为。而服务只是一个统称，在分层架构中笔筒发的分层里对应不同的服务。

## DDD模型元素

##### 1.值对象(value object):

**描述：**值对象是实体类的描述，一个值对象只描述一个实体，少数情况下一个值对象可以描述多个实体(值对象也有自己的行为，应该把属于值对象自己的行为放到值对象中)

**什么时候定义为值对象？**

1. 无唯一性标识。没有唯一标识的对象都是值对象(**这里的唯一标识不是技术主键id,而是在具体场景中的唯一标识**)
2. 验证逻辑。需要自我验证逻辑的属性(比如email属性，收发货地址等等)。若将这些字段放入实体类中，回到事实体类职责不够清洗，易变膨胀
3. 计算逻辑：需要有自我计算，换算逻辑的属性(比如重量属性，金额属性等)
4. 同类属性：多个属性在描述一个领域特征(比如联系方式[电话号码，座机，传真])

**如何存储？**

**通过其所属的实体类来触发存储，依赖于实体，不能独立存在**。如果够简单就随实体表一起存储，复杂的话也可以用单独的表存储



##### 2.实体(entity)

**描述：**实体是具有属性和**行为**的对象。***<font color="red">其本质特征为具有唯一标识和业务连续性变化</font>***。连续性变化是指随着时间的推移，属性会发生变化。而唯一标识在整个生命周期都是不变的并且是对外沟通的手段(比如订单的状态随着时间的变化而变化，而订单编号(唯一标识)是最终这一变化的)

**实体的创建：**

1. 属性：

   基本属性：基本类型表示的属性(eg：name,description等等)

   组合属性：非基本类型能表示的(weight等)，**组合属性会被设计为值对象**

2. 行为：

   变更属性的的行为(更改描述等)

   对自身属性的加工计算

   **<font color="red">跟别的属性协作的行为。需要依赖别的实体信息来做出决策(依赖的实体必须为同一个聚合中的实体，否则需要通过领域服务来实现)</font>**

   > ***<font color="red">注：实体的创建与增删改查不属于实体本身的行为，而是实体的生命周期管理，需要交给工厂和资源库来负责</font>***

**实体设计原则：**

- 将内聚高的属性尽量设计为一个单独的值对象

- 避免实体成为一个"贫血对象"
- 确保实体的创建返回的是一个有效实体(接受参数校验，初始化。抛出特定业务异常类异常)



##### 3.聚合(aggregate)

**描述：**引入聚合是为了划分对象之间的边界。一个聚合至少有一个实体，同时必须得有一个根实体承担主要的概念(理论上只可以直接联系聚合中的根实体)。在聚合边界之内需要保持领域概念的完整性与独立性。

**独立性与完整性**：

1. 独立性：根实体是访问聚合边界的唯一入口。若需要独立访问一个实体，则它只能作为聚合根。如果一个实体不是根实体，但同时真的需要被外界直接访问到，那么这个实体不应该在这个聚合中，应该独立成新的聚合。
2. 完整性：一个聚合中的对象需要共享生命周期，保证业务约束，事务的一致性。

**聚合设计原则：**

- 独立性：只有聚合跟才是访问聚合边界的唯一入口
- 访问原则：***<font color="red">聚合之间应该通过聚合根的身份标识进行引用，聚合内部可以通过对象引用</font>***。
  - 其他聚合需要加载一个聚合时，需要通过领域服务/应用服务协调，来返回聚合的完整内容(可以通过DAO的形式返回部分聚合信息。但是不推荐)
  - 新增一个聚合的时候，必须调用根实体必要的校验与领域逻辑，并传递给资源库一个完整聚合
  - 更新一个聚合的时候，必须调用根实体必要的校验和领域逻辑，并传递给资源库完整聚合(可以做到局部更新)
- 不要再聚合中使用资源库
- 聚合应该尽可能的小，从而带来更小的事物粒度与性能



##### 4.资源库(respository)

**描述：**资源库是对聚合访问的一种抽象。并为聚合提供添加，更新，获取等功能，来管理聚合的生命周期(**只是对聚合的生命周期管理的定义**)

> **【与工厂的区别】工厂负责聚合实例的生，垃圾回收负责聚合实例的死，<font color="red">资源库就负责聚合记录的查询与增删改。</font>**
>
> **【与DAO的区别】DAO模式也能做到数据访问，但DAO没有边界控制作用，没有聚合作为一个整体的概念，service类想查什么表就查什么表。**

**设计原则：**

1. 一个聚合一个资源库，<font color="red">***对聚合的生命周期的管理只有资源库这个入口***</font>
2. **<font color="red">资源库的接口在领域层，实现在基础设施层</font>**
3. <font color="red">**要访问聚合内其他实体和值对象，只能通过聚合对应的资源库进行**</font>
4. 在资源库内不能包含领域逻辑



##### 5.工厂(factory)

描述：工厂负责聚合对象的实例化操作(简单的时候可以直接new，复杂的时候通过工厂模式创建实现单例)



##### 6.***领域事件(domain event***)

**描述：**Martin Fowler对领域事件的定义是：“重要的事件肯定会在系统其它地方引起反应，因此理解为什么会有这些反应同样也很重要。”***<font color="red">一个领域事件可以理解为是发生在一个特定领域中的事件，是你希望在同一个领域中其他部分知道并产生后续动作的事件。</font>***但是并不是所有发生过的事情都可以成为领域事件。一个领域事件必须对业务有价值，有助于形成完整的业务闭环，也即一个领域事件将导致进一步的业务操作。领域事件可以是业务流程的一个步骤，例如订单提交，客户付费100元，订单完工等。领域事件也可以是定时发生的事情，例如每晚对账完成。或者是一个事件发生后引发的后续动作，例如客户输错密码三次后发生锁定账户的事件。

如果在通用语言中存在“当a发生时，我们就需要做到b。”这样的描述，则表明a可以定义成一个领域事件。领域事件的命名一般也就是“产生事件的对象名称+完成的动作的过去式”的形式，比如：订单已经发货的事件（OrderDispatchedEvent）、订单已被收货和确认的事件（OrderConfirmedEvent）等。

**种类：**

- **领域内事件：**

  如果一个应用服务对应的用例包含了多个聚合的状态改变。一个方案是通过领域内的事件来协同，但这带来异步响应编程模式。另一个方案是通过领域服务来编排多个聚合行为，这意味着所有事情都是在一个事务内同步完成。

  两个方案各有优劣，事件方式优点是松耦合，异步响应，缺点是流程不直观，从应用服务角度很难知道一个完整流程是什么，不太方便查找问题，事件响应逻辑出错会带来事务一致性问题。领域服务编排方案优点是流程直观，事务一致性。缺点是如果编排逻辑发生变化需要改动的逻辑多，流程太多的话可能会有性能问题。

  推荐：优先考虑使用领域服务编排完成。微服务架构下每个微服务的职责相对聚焦，一个用例通常不会同时修改多个聚合。如果需要修改多个聚合也应该是一个BC内的编排，可以通过应用服务启动的数据库事务来保证强一致性。另外领域设计提倡先从领域知识出发做聚合设计，技术实现问题比如性能问题往往放到后面做为走查领域设计的参考因素。如果没有强一致性需求的话，甚至可以通过向分布式消息队列发送领域间事件来达到自己发送自己消费的效果。

- **领域间事件：**

  DDD提倡BC间尽量解耦，尽可能使用发布订阅协作模式做上下游解耦，而发布订阅消息即指领域间事件(***如何传递消息往往借助分布式消息中间件的二方库，事务最终一致性也是消息中间件需要同步考虑的事情***)

  

##### 7.领域服务(doman service)

**描述：**领域服务是一种领域逻辑，***<font color="red">在领域服务中没有任何属性，只是一个领域行为。</font>***属于领域层。

**领域服务三个场景：**

- ***协调多个聚合完成业务操作***。因为聚合不能持有别的聚合对象，只能引用外部聚合根的唯一标识，因此需要跨聚合的业务操作需要领域服务来完成

- 不适合任何聚合的领域行为(比如说订单的导出等等)

- 领域行为需要访问包括数据库在内的外部资源协作的时候，需要在领域服务中实现(只需要实现业务的流程，而不需要考虑外部资源的实现)

  ```java
  // 如何协调聚合根Account和聚合根Transaction之间的关系，需要用到领域服务来协调和封装
  public class WithdrawingDomainService {
      @Repository
      private AccountRepository accountRepo;
      @Repository
      private TransactionRepository transRepo;
   
      public void withDraw(AccountId id, Amount amount) {
          AccountEntity account = accountRepo.findBy(id);
          account.decrease(amount);
          accountRepo.save(account);
   
          Transaction transaction = Transaction.createFrom(id, amount);
          transRepo.save(transaction);
      }
    
  }
  
  //demo2
  public class JourneyTemplateCmdDomainService {
  
      @Resource
      private JourneyTemplateRepository journeyTemplateRepository;
  
      public Long updateJourneyTemplate(String appId, String orgId, String userId, JourneyTemplateEntity entity) {
          return journeyTemplateRepository.update(appId, orgId, userId, entity);
      }
  
      public Boolean deleteJourneyTemplate(String appId, String orgId, String userId, Long journeyTemplateId) {
          JourneyTemplateEntity entity = new JourneyTemplateEntity();
          entity.setId(JourneyTemplateId.valueOf(journeyTemplateId));
          entity.setAppId(appId);
          entity.setOrgId(orgId);
  
          return journeyTemplateRepository.delete(appId, orgId, entity) == 1 ? Boolean.TRUE : Boolean.FALSE;
      }
  
  }
  
  
  
  ```

**领域服务设计原则：**

- 领域服务的力度应该小一些，只做一件事情，便于应用服务调用
- 作为参考可以要求领域名称包含一个动词



##### 8.应用服务(application service)

**描述：**<font color="red">***应用服务属于分层架构里的应用层，每一个用户用例对应一个方法。***</font>在应用层服务中，不能做任何的业务逻辑的决策。

> ***<font color="red">应用服务方法的入参和出参都是DTO，调用领域层需要传入entity，返回interface层需要把entity转成DTO</font>***

**应用服务的两个典型场景：**

- 不包含领域逻辑的业务服务为应用服务
- 与横切关注点协作的服务应被定义为应用服务：事务、认证授权等

**<font color="red">*DTO的设计原则：*</font>**

- 入参DTO尽量少暴露字段
- 多个用例下尽量不复用入参DTO
- 尽量复用出参DTO（可以比要求的多暴露字段）
- 创建和更新用例下，返回整个实体
- DTO的校验不包含领域校验逻辑，比如唯一性校验



## 领域模型与元素之间的关系

##### 领域模型元素间的访问边界

|          | 应用服务                               | 领域服务                                                   | 聚合/根实体                                                  | 资源库                                                       |
| :------- | :------------------------------------- | :--------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 应用服务 | 一个应用服务**不要**访问另一个应用服务 | 应用服务能访问多个领域服务                                 | 应用服务能访问聚合即根实体                                   | 应用服务能访问资源库                                         |
| 聚合     | 聚合**不能**访问应用服务               | 聚合**不能**访问领域服务                                   | ***<font color="red">通过领域服务来协作多个聚合，一个聚合只能接受另一个聚合作为参数传入[只能接受另一个聚合的参数，而非实体]</font>*** | 聚合**不能**访问资源库（聚合是业务的最小边界，聚合内不依赖任何外部资源） |
| 资源库   | 资源库**不能**访问应用服务             | 资源库**不能**访问领域服务                                 | ***<font color="red">资源库不能访问聚合[只能访问资源库来实现逻辑，因为是以聚合为整体的]，根实体作为入参传入资源库实现接口，需要先被转换成持久化对象<font color="purple"></font></font>*** | 一个资源库**不能**访问另一个资源库                           |
| 领域服务 | 领域服务**不能**访问应用服务           | 如果需要组装出粒度大的领域服务，领域服务能访问多个领域服务 | 领域服务能访问聚合即根实体                                   | 领域服务能访问资源库                                         |

##### 模型对象设计顺序

**描述：**再业务中，对业务需求的分析是自顶向下的，为业务流程-->用户用例-->领域模型。***<font color="red">而设计过程是自下而上的，为先值对象 → 再实体 → 再聚合 → 再领域服务→ 最后是应用服务。</font>***优先考虑领域是否应该为值对象，其次是否为实体，划分出聚合。不属于实体或值对象中的领域行为放到领域服务，需要协调聚合的领域行为设计为领域服务或者应用服务。

图解：

![模型对象设计](/Users/chenyongcheng/programmingSoftware/markdown/markdown_pic/模型对象设计.png)



## DDD架构

##### DDD的数据模型

- entity：具有数据字段和内聚的行为，不对外部产生依赖，也是一种pojo对象
- value object：具有数据字段和内聚的行为，不对外部产生依赖，也是一种pojo对象。有些地方把跟UI展示数据有关的也有叫view object，建议改为UI Object简称为UO
- persistent object(PO)：维护与数据库表字段的映射关系，直接跟ORM框架无缝集成

> - 贫血模型：实体类对象里面只有属性和对应的setter与getterff。
> - 富血模型：除了属性与对应的setter,getter，按照职责单一原则把归属于实体类的行为也定义再实体类中[***<font color="red">DDD中使用</font>***]

##### 与传统分层架构的对比

- 传统的三层架构

  业务服务层的ServiceImpl是一个上帝类，包括事务脚本，过程业务等逻辑的实现。其中包括参数的验证(validation),convert,业务逻辑，以及从RPC,DAO获取数据等等诸多功能。

- 整洁分层架构

  ![DDD分层架构v4](/Users/chenyongcheng/programmingSoftware/markdown/markdown_pic/DDD分层架构v4.jpg)

  整洁分层架构是在整洁架构的各层次上加上DDD的基础，综合洋葱架构而来，具有以下特点：

  1. 共分为五层：interface层，API层，application层，domain层，infrastructure层。每层是一个jar包，bootstrap类放在interface层，单独出来也可以。
  2. interface层以开放主机服务的方式对接BC的外部请求(对sdk的接口做网关，协议，主机等配置)
  3. <mark><font color="purple">sdk层是向天路接口暴露用途(***<font color="purple">接口提供给天路</font>***)，若无天路则没有此层</font> <font color="green">***???????不太明白***</font> </mark>
  4. ***domain层不依赖其他层，是以聚合为单位放置代码，便于以后的系统拆分与优化。domain通过adaptor下的接口做到依赖倒置***(adaptor接口参数不能体现具体的实现逻辑)，***<font color="red">domain里的实现逻辑只依赖接口。</font>***
  5. infrasturcture负责向BC外部发出申请(申请并获得数据)

##### 命名规范

|      | 领域元素           | 英文                 | 命名规则                                                     | 举例                                              |
| ---- | ------------------ | -------------------- | ------------------------------------------------------------ | ------------------------------------------------- |
| 1    | 实体               | Entity               | 类名+Entity                                                  | OrderEntity                                       |
| 2    | 值对象             | Value Object         | 类名+VO                                                      | OrderVO                                           |
| 3    | 领域服务           | Domain Service       | 类：领域服务类+动词缩写+DomainService<br/>方法:动词+名词     | 类：OrderCmdDomainService<br/>方法：UpdateOrder   |
| 4    | 工厂               | Factory              | 类名+Factory                                                 | OrderFactory                                      |
| 5    | 资源库             | Respository          | 类名+Respository                                             | OrderRespository                                  |
| 6    | 领域事件           | Domain Event         | 类名+动词+Event                                              | OrderCreateEvent                                  |
| 7    | 应用服务           | Application Service  | 类名+AppService                                              | UserGroupAppService                               |
| 8    | DTO                | data transfer object | 类名分别以Cmd,Qry,UO,DTO结尾                                 | JourneyTemplateSaveCmd                            |
| 9    | 对应db表的数据对象 | PO                   | 类名+PO                                                      | OrderPO                                           |
| 10   | 转换类             | Convertor            | ***app层：在DTO与entity之间相互转换<br/>infra层：在PO与entity之间相互转换*** | UserGroupEntityConvertor<br/>UserGroupVOConvertor |
| 11   | 测试类             | xxxTest              | 单元测试，集成测试                                           | OrderEntityTest                                   |

> **SDK里的DTO：**
>
> 1. **入参xxxCmd：表示写数据接口的入参**
> 2. **入参xxxQry：表示读数据接口的入参**
> 3. **出参xxxUO，表示面向UI/视图组装的对象**
> 4. **出参xxxDTO，表示面向接口组装的对象**
> 5. **不符合上述场景的用xxxDTO**

**命名原则**：***<font color="red">interface、app、domain层尽量用业务含义的命名，infra层命名可以跟技术选型有关。</font>***

**实践**：。

| CRUD     | 非infra层的接口名推荐 |
| :------- | :-------------------- |
| 新增     | create/add            |
| 修改     | update                |
| 删除     | remove/delete         |
| 单个查询 | get                   |
| 列表查询 | list                  |
| 分页     | page                  |
| 统计     | count                 |

**举例**：

| 意图             | 更业务化   | 太技术化                     | 解释                                                |
| :--------------- | :--------- | :--------------------------- | :-------------------------------------------------- |
| 下订单           | placeOrder | createOrder、addOrder        | 对于没有太多业务含义的实体新增，用add或者create亦可 |
| 获取、查询、搜索 | get        | find、query、fetch、retrieve | 技术化是指更容易思维定势到资源的存储方式            |

## DDD运行流程及包用途详解(结合DDD骨架demo)

##### 包用途详解

![image-20210319212249773](/Users/chenyongcheng/Library/Application Support/typora-user-images/image-20210319212249773.png)

##### 运行流程

![DDD执行流程](/Users/chenyongcheng/programmingSoftware/markdown/markdown_pic/DDD执行流程.png)

##### 各个分层对应的各种数据对象解释

**原则：**不同的分层里要用合适的数据对象。命名带上相应后缀。

1. interface、application层：入参是ui或者open api传入的DTO，消息对象。出参是DTO或者UO
2. domain层：只能见到领域对象 - 聚合、实体Entity、值对象VO
3. infra层：跟资源库相关的是持久化对象PO；跟adaptor相关的是目标rpc接口的sdk里定义的xxxDTO，建议转换为xxxVO在domain层使用，作为对外部服务xxxDTO的防腐。即domain层不依赖rpc provider的sdk包
4. sdk层：尽可能少的暴露信息，特别是接口的入参对象设计要遵照"最小知识"，使用方知道的越少越好。

## DDD架构设计原则

##### 1、<mark><font color="green">sdk层设计???</font></mark>

> ***<font color="red">sdk包的依赖要尽可能的少，除了依赖天路sdk，最多再依赖tcom-xxx等公共库</font>***

##### 2、interface层设计

***<font color="red">用户接口层，负责对外暴露开发主机服务，对接各种协议，</font>***经过了接口层后最终都要转成应用服务所能认识的协议，并通过应用服务入参传入应用层。

- 暴露并实现接口：rpc、rest、mq subscriber
- 网关注册@Register，Swagger支持比如@ApiOperation
- 协议转换：请求上游如果不是直接对接前端，在gateway网关层已经做了协议转换
- 接口限流等功能
- 入参定义：天路rpc的接口入参在sdk包里已经定义。http、mq consumer接口的入参对象可以定义在app层，interface层共用。
- 入参校验（只包含判断是否null等没有领域含义的校验逻辑）
- 依赖application层,***<font color="red">不要做本属于application层的业务逻辑</font>***

3、application层设计

应用层类似设计模式的facade模式，把里层的领域层服务做编排，对外层提供粗粒度的接口。所以应用层主要做两件事：<font color="red">***1. 编排用例，一个接口就对应了业务场景的用例。2. 处理一些横切面的事情。***</font>

- 编排用例：绝大部分情况下应用服务通过调用领域服务来编排业务流程
  - 启动事务，目前统一用dataio提供的注解@DBTransactional
  - 对入参做必要验证。注意：一定要思考哪些逻辑该在application层做，涉及到实体/值对象的属性校验肯定要下放到领域层的实体/值对象自己承担。
  - DTO到entity的互转：在访问domain层之前之后
  - 调用一个或者多个领域服务
- 横切点功能：事务开启在应用层、打日志、异常处理
- 依赖情况：domain层，dataio sdk

##### 4、domain层

- 所有业务逻辑相关的代码都应该放在这个层，不应出现任何跟具体技术相关的词汇，比如资源相关的操作只有repository，没有dataio、mybatis、redis等具体实现repository的技术词汇
- domain层除了依赖一些公共库（比如tcom-xxx、ddd-framework）之外不能依赖任何层，通过相应的adaptor接口做到和infra层的依赖倒置（对应DDD里的防腐层设计）

##### 5、infrastructure层

本BC访问外部系统、组件需要的逻辑都放在本层。主要实现一系列adaptor接口，典型的adaptor有：

- 对资源存储的访问比如数据库、缓存
- 对内部其他系统的适配逻辑，通过rpc或者http访问。熔断逻辑可在此维护。对rpc调用得到的出参进行防腐处理详见<*各个分层对应的各种数据对象解释*>
- 对外部第三方厂商系统的适配逻辑
- 对基础框架的适配逻辑，比如消息队列、配置中心、文件等。其中rcc配置中心目前对应用逻辑无侵入，当作正常的spring配置项使用。









